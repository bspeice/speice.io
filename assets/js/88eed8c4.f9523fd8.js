"use strict";(self.webpackChunkspeice_io=self.webpackChunkspeice_io||[]).push([["1652"],{92184:function(e,n,t){t.r(n),t.d(n,{assets:function(){return c},contentTitle:function(){return a},default:function(){return h},frontMatter:function(){return r},metadata:function(){return s},toc:function(){return o}});var s=t(1495),i=t(85893),l=t(50065);let r={slug:"2019/02/the-whole-world",title:"Allocations in Rust: Global memory",date:new Date("2019-02-05T12:00:00.000Z"),authors:["bspeice"],tags:[]},a=void 0,c={authorsImageUrls:[void 0]},o=[{value:"<code>const</code> values",id:"const-values",level:2},{value:"Read-Only",id:"read-only",level:3},{value:"Initialization",id:"initialization",level:3},{value:"Copying",id:"copying",level:3},{value:"<code>static</code> values",id:"static-values",level:2},{value:"Memory Uniqueness",id:"memory-uniqueness",level:3},{value:"Initialization",id:"initialization-1",level:3},{value:"The <code>Sync</code> marker",id:"the-sync-marker",level:3},{value:"Interior mutability",id:"interior-mutability",level:3}];function d(e){let n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,l.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["The first memory type we'll look at is pretty special: when Rust can prove that a ",(0,i.jsx)(n.em,{children:"value"})," is fixed\nfor the life of a program (",(0,i.jsx)(n.code,{children:"const"}),"), and when a ",(0,i.jsx)(n.em,{children:"reference"})," is unique for the life of a program\n(",(0,i.jsx)(n.code,{children:"static"})," as a declaration, not\n",(0,i.jsx)(n.a,{href:"https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html#the-static-lifetime",children:(0,i.jsx)(n.code,{children:"'static"})})," as a\nlifetime), we can make use of global memory. This special section of data is embedded directly in\nthe program binary so that variables are ready to go once the program loads; no additional\ncomputation is necessary."]}),"\n",(0,i.jsxs)(n.p,{children:["Understanding the value/reference distinction is important for reasons we'll go into below, and\nwhile the\n",(0,i.jsx)(n.a,{href:"https://github.com/rust-lang/rfcs/blob/master/text/0246-const-vs-static.md",children:"full specification"})," for\nthese two keywords is available, we'll take a hands-on approach to the topic."]}),"\n",(0,i.jsxs)(n.h2,{id:"const-values",children:[(0,i.jsx)(n.code,{children:"const"})," values"]}),"\n",(0,i.jsxs)(n.p,{children:["When a ",(0,i.jsx)(n.em,{children:"value"}),' is guaranteed to be unchanging in your program (where "value" may be scalars,\n',(0,i.jsx)(n.code,{children:"struct"}),"s, etc.), you can declare it ",(0,i.jsx)(n.code,{children:"const"}),". This tells the compiler that it's safe to treat the\nvalue as never changing, and enables some interesting optimizations; not only is there no\ninitialization cost to creating the value (it is loaded at the same time as the executable parts of\nyour program), but the compiler can also copy the value around if it speeds up the code."]}),"\n",(0,i.jsxs)(n.p,{children:["The points we need to address when talking about ",(0,i.jsx)(n.code,{children:"const"})," are:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Const"})," values are stored in read-only memory - it's impossible to modify."]}),"\n",(0,i.jsxs)(n.li,{children:["Values resulting from calling a ",(0,i.jsx)(n.code,{children:"const fn"})," are materialized at compile-time."]}),"\n",(0,i.jsxs)(n.li,{children:["The compiler may (or may not) copy ",(0,i.jsx)(n.code,{children:"const"})," values wherever it chooses."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"read-only",children:"Read-Only"}),"\n",(0,i.jsxs)(n.p,{children:['The first point is a bit strange - "read-only memory."\n',(0,i.jsx)(n.a,{href:"https://doc.rust-lang.org/book/ch03-01-variables-and-mutability.html#differences-between-variables-and-constants",children:"The Rust book"}),"\nmentions in a couple places that using ",(0,i.jsx)(n.code,{children:"mut"})," with constants is illegal, but it's also important to\ndemonstrate just how immutable they are. ",(0,i.jsx)(n.em,{children:"Typically"})," in Rust you can use\n",(0,i.jsx)(n.a,{href:"https://doc.rust-lang.org/book/ch15-05-interior-mutability.html",children:"interior mutability"})," to modify\nthings that aren't declared ",(0,i.jsx)(n.code,{children:"mut"}),".\n",(0,i.jsx)(n.a,{href:"https://doc.rust-lang.org/std/cell/struct.RefCell.html",children:(0,i.jsx)(n.code,{children:"RefCell"})})," provides an example of this\npattern in action:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'use std::cell::RefCell;\n\nfn my_mutator(cell: &RefCell<u8>) {\n    // Even though we\'re given an immutable reference,\n    // the `replace` method allows us to modify the inner value.\n    cell.replace(14);\n}\n\nfn main() {\n    let cell = RefCell::new(25);\n    // Prints out 25\n    println!("Cell: {:?}", cell);\n    my_mutator(&cell);\n    // Prints out 14\n    println!("Cell: {:?}", cell);\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["--\n",(0,i.jsx)(n.a,{href:"https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=8e4bea1a718edaff4507944e825a54b2",children:"Rust Playground"})]}),"\n",(0,i.jsxs)(n.p,{children:["When ",(0,i.jsx)(n.code,{children:"const"})," is involved though, interior mutability is impossible:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'use std::cell::RefCell;\n\nconst CELL: RefCell<u8> = RefCell::new(25);\n\nfn my_mutator(cell: &RefCell<u8>) {\n    cell.replace(14);\n}\n\nfn main() {\n    // First line prints 25 as expected\n    println!("Cell: {:?}", &CELL);\n    my_mutator(&CELL);\n    // Second line *still* prints 25\n    println!("Cell: {:?}", &CELL);\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["--\n",(0,i.jsx)(n.a,{href:"https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=88fe98110c33c1b3a51e341f48b8ae00",children:"Rust Playground"})]}),"\n",(0,i.jsxs)(n.p,{children:["And a second example using ",(0,i.jsx)(n.a,{href:"https://doc.rust-lang.org/std/sync/struct.Once.html",children:(0,i.jsx)(n.code,{children:"Once"})}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'use std::sync::Once;\n\nconst SURPRISE: Once = Once::new();\n\nfn main() {\n    // This is how `Once` is supposed to be used\n    SURPRISE.call_once(|| println!("Initializing..."));\n    // Because `Once` is a `const` value, we never record it\n    // having been initialized the first time, and this closure\n    // will also execute.\n    SURPRISE.call_once(|| println!("Initializing again???"));\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["--\n",(0,i.jsx)(n.a,{href:"https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=c3cc5979b5e5434eca0f9ec4a06ee0ed",children:"Rust Playground"})]}),"\n",(0,i.jsxs)(n.p,{children:["When the\n",(0,i.jsxs)(n.a,{href:"https://github.com/rust-lang/rfcs/blob/26197104b7bb9a5a35db243d639aee6e46d35d75/text/0246-const-vs-static.md",children:[(0,i.jsx)(n.code,{children:"const"})," specification"]}),"\nrefers to ",(0,i.jsx)(n.a,{href:"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3055.pdf",children:'"rvalues"'}),", this\nbehavior is what they refer to. ",(0,i.jsx)(n.a,{href:"https://github.com/rust-lang/rust-clippy",children:"Clippy"})," will treat this\nas an error, but it's still something to be aware of."]}),"\n",(0,i.jsx)(n.h3,{id:"initialization",children:"Initialization"}),"\n",(0,i.jsxs)(n.p,{children:["The next thing to mention is that ",(0,i.jsx)(n.code,{children:"const"})," values are loaded into memory ",(0,i.jsx)(n.em,{children:"as part of your program\nbinary"}),". Because of this, any ",(0,i.jsx)(n.code,{children:"const"}),' values declared in your program will be "realized" at\ncompile-time; accessing them may trigger a main-memory lookup (with a fixed address, so your CPU may\nbe able to prefetch the value), but that\'s it.']}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"use std::cell::RefCell;\n\nconst CELL: RefCell<u32> = RefCell::new(24);\n\npub fn multiply(value: u32) -> u32 {\n    // CELL is stored at `.L__unnamed_1`\n    value * (*CELL.get_mut())\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["-- ",(0,i.jsx)(n.a,{href:"https://godbolt.org/z/Th8boO",children:"Compiler Explorer"})]}),"\n",(0,i.jsxs)(n.p,{children:["The compiler creates one ",(0,i.jsx)(n.code,{children:"RefCell"}),", uses it everywhere, and never needs to call the ",(0,i.jsx)(n.code,{children:"RefCell::new"}),"\nfunction."]}),"\n",(0,i.jsx)(n.h3,{id:"copying",children:"Copying"}),"\n",(0,i.jsxs)(n.p,{children:["If it's helpful though, the compiler can choose to copy ",(0,i.jsx)(n.code,{children:"const"})," values."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"const FACTOR: u32 = 1000;\n\npub fn multiply(value: u32) -> u32 {\n    // See assembly line 4 for the `mov edi, 1000` instruction\n    value * FACTOR\n}\n\npub fn multiply_twice(value: u32) -> u32 {\n    // See assembly lines 22 and 29 for `mov edi, 1000` instructions\n    value * FACTOR * FACTOR\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["-- ",(0,i.jsx)(n.a,{href:"https://godbolt.org/z/ZtS54X",children:"Compiler Explorer"})]}),"\n",(0,i.jsxs)(n.p,{children:["In this example, the ",(0,i.jsx)(n.code,{children:"FACTOR"})," value is turned into the ",(0,i.jsx)(n.code,{children:"mov edi, 1000"})," instruction in both the\n",(0,i.jsx)(n.code,{children:"multiply"})," and ",(0,i.jsx)(n.code,{children:"multiply_twice"}),' functions; the "1000" value is never "stored" anywhere, as it\'s\nsmall enough to inline into the assembly instructions.']}),"\n",(0,i.jsxs)(n.p,{children:["Finally, getting the address of a ",(0,i.jsx)(n.code,{children:"const"})," value is possible, but not guaranteed to be unique\n(because the compiler can choose to copy values). I was unable to get non-unique pointers in my\ntesting (even using different crates), but the specifications are clear enough: ",(0,i.jsxs)(n.em,{children:["don't rely on\npointers to ",(0,i.jsx)(n.code,{children:"const"})," values being consistent"]}),". To be frank, caring about locations for ",(0,i.jsx)(n.code,{children:"const"})," values\nis almost certainly a code smell."]}),"\n",(0,i.jsxs)(n.h2,{id:"static-values",children:[(0,i.jsx)(n.code,{children:"static"})," values"]}),"\n",(0,i.jsxs)(n.p,{children:["Static variables are related to ",(0,i.jsx)(n.code,{children:"const"})," variables, but take a slightly different approach. When we\ndeclare that a ",(0,i.jsx)(n.em,{children:"reference"})," is unique for the life of a program, you have a ",(0,i.jsx)(n.code,{children:"static"})," variable\n(unrelated to the ",(0,i.jsx)(n.code,{children:"'static"})," lifetime). Because of the reference/value distinction with\n",(0,i.jsx)(n.code,{children:"const"}),"/",(0,i.jsx)(n.code,{children:"static"}),', static variables behave much more like typical "global" variables.']}),"\n",(0,i.jsxs)(n.p,{children:["But to understand ",(0,i.jsx)(n.code,{children:"static"}),", here's what we'll look at:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"static"})," variables are globally unique locations in memory."]}),"\n",(0,i.jsxs)(n.li,{children:["Like ",(0,i.jsx)(n.code,{children:"const"}),", ",(0,i.jsx)(n.code,{children:"static"})," variables are loaded at the same time as your program being read into\nmemory."]}),"\n",(0,i.jsxs)(n.li,{children:["All ",(0,i.jsx)(n.code,{children:"static"})," variables must implement the\n",(0,i.jsx)(n.a,{href:"https://doc.rust-lang.org/std/marker/trait.Sync.html",children:(0,i.jsx)(n.code,{children:"Sync"})})," marker trait."]}),"\n",(0,i.jsxs)(n.li,{children:["Interior mutability is safe and acceptable when using ",(0,i.jsx)(n.code,{children:"static"})," variables."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"memory-uniqueness",children:"Memory Uniqueness"}),"\n",(0,i.jsxs)(n.p,{children:["The single biggest difference between ",(0,i.jsx)(n.code,{children:"const"})," and ",(0,i.jsx)(n.code,{children:"static"})," is the guarantees provided about\nuniqueness. Where ",(0,i.jsx)(n.code,{children:"const"})," variables may or may not be copied in code, ",(0,i.jsx)(n.code,{children:"static"})," variables are\nguarantee to be unique. If we take a previous ",(0,i.jsx)(n.code,{children:"const"})," example and change it to ",(0,i.jsx)(n.code,{children:"static"}),", the\ndifference should be clear:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"static FACTOR: u32 = 1000;\n\npub fn multiply(value: u32) -> u32 {\n    // The assembly to `mul dword ptr [rip + example::FACTOR]` is how FACTOR gets used\n    value * FACTOR\n}\n\npub fn multiply_twice(value: u32) -> u32 {\n    // The assembly to `mul dword ptr [rip + example::FACTOR]` is how FACTOR gets used\n    value * FACTOR * FACTOR\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["-- ",(0,i.jsx)(n.a,{href:"https://godbolt.org/z/uxmiRQ",children:"Compiler Explorer"})]}),"\n",(0,i.jsxs)(n.p,{children:["Where ",(0,i.jsx)(n.a,{href:"#copying",children:"previously"})," there were plenty of references to multiplying by 1000, the new\nassembly refers to ",(0,i.jsx)(n.code,{children:"FACTOR"})," as a named memory location instead. No initialization work needs to be\ndone, but the compiler can no longer prove the value never changes during execution."]}),"\n",(0,i.jsx)(n.h3,{id:"initialization-1",children:"Initialization"}),"\n",(0,i.jsx)(n.p,{children:"Next, let's talk about initialization. The simplest case is initializing static variables with\neither scalar or struct notation:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'#[derive(Debug)]\nstruct MyStruct {\n    x: u32\n}\n\nstatic MY_STRUCT: MyStruct = MyStruct {\n    // You can even reference other statics\n    // declared later\n    x: MY_VAL\n};\n\nstatic MY_VAL: u32 = 24;\n\nfn main() {\n    println!("Static MyStruct: {:?}", MY_STRUCT);\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["--\n",(0,i.jsx)(n.a,{href:"https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=b538dbc46076f12db047af4f4403ee6e",children:"Rust Playground"})]}),"\n",(0,i.jsxs)(n.p,{children:["Things can get a bit weirder when using ",(0,i.jsx)(n.code,{children:"const fn"})," though. In most cases, it just works:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'#[derive(Debug)]\nstruct MyStruct {\n    x: u32\n}\n\nimpl MyStruct {\n    const fn new() -> MyStruct {\n        MyStruct { x: 24 }\n    }\n}\n\nstatic MY_STRUCT: MyStruct = MyStruct::new();\n\nfn main() {\n    println!("const fn Static MyStruct: {:?}", MY_STRUCT);\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["--\n",(0,i.jsx)(n.a,{href:"https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=8c796a6e7fc273c12115091b707b0255",children:"Rust Playground"})]}),"\n",(0,i.jsxs)(n.p,{children:["However, there's a caveat: you're currently not allowed to use ",(0,i.jsx)(n.code,{children:"const fn"})," to initialize static\nvariables of types that aren't marked ",(0,i.jsx)(n.code,{children:"Sync"}),". For example,\n",(0,i.jsx)(n.a,{href:"https://doc.rust-lang.org/std/cell/struct.RefCell.html#method.new",children:(0,i.jsx)(n.code,{children:"RefCell::new()"})})," is a\n",(0,i.jsx)(n.code,{children:"const fn"}),", but because\n",(0,i.jsxs)(n.a,{href:"https://doc.rust-lang.org/std/cell/struct.RefCell.html#impl-Sync",children:[(0,i.jsx)(n.code,{children:"RefCell"})," isn't ",(0,i.jsx)(n.code,{children:"Sync"})]}),", you'll\nget an error at compile time:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"use std::cell::RefCell;\n\n// error[E0277]: `std::cell::RefCell<u8>` cannot be shared between threads safely\nstatic MY_LOCK: RefCell<u8> = RefCell::new(0);\n"})}),"\n",(0,i.jsxs)(n.p,{children:["--\n",(0,i.jsx)(n.a,{href:"https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=c76ef86e473d07117a1700e21fd45560",children:"Rust Playground"})]}),"\n",(0,i.jsxs)(n.p,{children:["It's likely that this will\n",(0,i.jsx)(n.a,{href:"https://github.com/rust-lang/rfcs/blob/master/text/0911-const-fn.md",children:"change in the future"})," though."]}),"\n",(0,i.jsxs)(n.h3,{id:"the-sync-marker",children:["The ",(0,i.jsx)(n.code,{children:"Sync"})," marker"]}),"\n",(0,i.jsxs)(n.p,{children:["Which leads well to the next point: static variable types must implement the\n",(0,i.jsxs)(n.a,{href:"https://doc.rust-lang.org/std/marker/trait.Sync.html",children:[(0,i.jsx)(n.code,{children:"Sync"})," marker"]}),". Because they're globally\nunique, it must be safe for you to access static variables from any thread at any time. Most\n",(0,i.jsx)(n.code,{children:"struct"})," definitions automatically implement the ",(0,i.jsx)(n.code,{children:"Sync"})," trait because they contain only elements\nwhich themselves implement ",(0,i.jsx)(n.code,{children:"Sync"})," (read more in the\n",(0,i.jsx)(n.a,{href:"https://doc.rust-lang.org/nomicon/send-and-sync.html",children:"Nomicon"}),"). This is why earlier examples could\nget away with initializing statics, even though we never included an ",(0,i.jsx)(n.code,{children:"impl Sync for MyStruct"})," in the\ncode. To demonstrate this property, Rust refuses to compile our earlier example if we add a\nnon-",(0,i.jsx)(n.code,{children:"Sync"})," element to the ",(0,i.jsx)(n.code,{children:"struct"})," definition:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"use std::cell::RefCell;\n\nstruct MyStruct {\n    x: u32,\n    y: RefCell<u8>,\n}\n\n// error[E0277]: `std::cell::RefCell<u8>` cannot be shared between threads safely\nstatic MY_STRUCT: MyStruct = MyStruct {\n    x: 8,\n    y: RefCell::new(8)\n};\n"})}),"\n",(0,i.jsxs)(n.p,{children:["--\n",(0,i.jsx)(n.a,{href:"https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=40074d0248f056c296b662dbbff97cfc",children:"Rust Playground"})]}),"\n",(0,i.jsx)(n.h3,{id:"interior-mutability",children:"Interior mutability"}),"\n",(0,i.jsxs)(n.p,{children:["Finally, while ",(0,i.jsx)(n.code,{children:"static mut"})," variables are allowed, mutating them is an ",(0,i.jsx)(n.code,{children:"unsafe"})," operation. If we\nwant to stay in ",(0,i.jsx)(n.code,{children:"safe"})," Rust, we can use interior mutability to accomplish similar goals:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'use std::sync::Once;\n\n// This example adapted from https://doc.rust-lang.org/std/sync/struct.Once.html#method.call_once\nstatic INIT: Once = Once::new();\n\nfn main() {\n    // Note that while `INIT` is declared immutable, we\'re still allowed\n    // to mutate its interior\n    INIT.call_once(|| println!("Initializing..."));\n    // This code won\'t panic, as the interior of INIT was modified\n    // as part of the previous `call_once`\n    INIT.call_once(|| panic!("INIT was called twice!"));\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["--\n",(0,i.jsx)(n.a,{href:"https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=3ba003a981a7ed7400240caadd384d59",children:"Rust Playground"})]})]})}function h(e={}){let{wrapper:n}={...(0,l.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},50065:function(e,n,t){t.d(n,{Z:function(){return a},a:function(){return r}});var s=t(67294);let i={},l=s.createContext(i);function r(e){let n=s.useContext(l);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(l.Provider,{value:n},e.children)}},1495:function(e){e.exports=JSON.parse('{"permalink":"/2019/02/the-whole-world","source":"@site/blog/2019-02-05-the-whole-world/index.mdx","title":"Allocations in Rust: Global memory","description":"The first memory type we\'ll look at is pretty special: when Rust can prove that a value is fixed","date":"2019-02-05T12:00:00.000Z","tags":[],"readingTime":7.485,"hasTruncateMarker":true,"authors":[{"name":"Bradlee Speice","socials":{"github":"https://github.com/bspeice"},"key":"bspeice","page":null}],"frontMatter":{"slug":"2019/02/the-whole-world","title":"Allocations in Rust: Global memory","date":"2019-02-05T12:00:00.000Z","authors":["bspeice"],"tags":[]},"unlisted":false,"lastUpdatedAt":1731204300000,"prevItem":{"title":"Allocations in Rust: Fixed memory","permalink":"/2019/02/stacking-up"},"nextItem":{"title":"Allocations in Rust: Foreword","permalink":"/2019/02/understanding-allocations-in-rust"}}')}}]);