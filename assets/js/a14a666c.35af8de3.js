"use strict";(self.webpackChunkspeice_io=self.webpackChunkspeice_io||[]).push([["1000"],{65249:function(e,t,n){n.r(t),n.d(t,{assets:function(){return c},contentTitle:function(){return s},default:function(){return m},frontMatter:function(){return a},metadata:function(){return o},toc:function(){return l}});var o=n(82340),r=n(85893),i=n(50065);let a={slug:"2019/02/stacking-up",title:"Allocations in Rust: Fixed memory",date:new Date("2019-02-06T12:00:00.000Z"),authors:["bspeice"],tags:[]},s=void 0,c={authorsImageUrls:[void 0]},l=[];function u(e){let t={code:"code",p:"p",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"const"})," and ",(0,r.jsx)(t.code,{children:"static"})," are perfectly fine, but it's relatively rare that we know at compile-time about\neither values or references that will be the same for the duration of our program. Put another way,\nit's not often the case that either you or your compiler knows how much memory your entire program\nwill ever need."]}),"\n",(0,r.jsx)(t.p,{children:'However, there are still some optimizations the compiler can do if it knows how much memory\nindividual functions will need. Specifically, the compiler can make use of "stack" memory (as\nopposed to "heap" memory) which can be managed far faster in both the short- and long-term.'})]})}function m(e={}){let{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}},50065:function(e,t,n){n.d(t,{Z:function(){return s},a:function(){return a}});var o=n(67294);let r={},i=o.createContext(r);function a(e){let t=o.useContext(i);return o.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),o.createElement(i.Provider,{value:t},e.children)}},82340:function(e){e.exports=JSON.parse('{"permalink":"/2019/02/stacking-up","source":"@site/blog/2019-02-06-stacking-up/index.mdx","title":"Allocations in Rust: Fixed memory","description":"const and static are perfectly fine, but it\'s relatively rare that we know at compile-time about","date":"2019-02-06T12:00:00.000Z","tags":[],"readingTime":15.165,"hasTruncateMarker":true,"authors":[{"name":"Bradlee Speice","socials":{"github":"https://github.com/bspeice"},"key":"bspeice","page":null}],"frontMatter":{"slug":"2019/02/stacking-up","title":"Allocations in Rust: Fixed memory","date":"2019-02-06T12:00:00.000Z","authors":["bspeice"],"tags":[]},"unlisted":false,"lastUpdatedAt":1731204300000,"prevItem":{"title":"Allocations in Rust: Dynamic memory","permalink":"/2019/02/a-heaping-helping"},"nextItem":{"title":"Allocations in Rust: Global memory","permalink":"/2019/02/the-whole-world"}}')}}]);