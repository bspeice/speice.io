"use strict";(self.webpackChunkspeice_io=self.webpackChunkspeice_io||[]).push([["3956"],{4297:function(e,t,n){n.r(t),n.d(t,{assets:function(){return l},contentTitle:function(){return a},default:function(){return u},frontMatter:function(){return o},metadata:function(){return i},toc:function(){return c}});var i=n(50610),s=n(85893),r=n(50065);let o={slug:"2019/02/summary",title:"Allocations in Rust: Summary",date:new Date("2019-02-09T12:00:00.000Z"),authors:["bspeice"],tags:[]},a=void 0,l={authorsImageUrls:[void 0]},c=[];function d(e){let t={a:"a",code:"code",img:"img",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(t.p,{children:["While there's a lot of interesting detail captured in this series, it's often helpful to have a\ndocument that answers some \"yes/no\" questions. You may not care about what an ",(0,s.jsx)(t.code,{children:"Iterator"})," looks like\nin assembly, you just need to know whether it allocates an object on the heap or not. And while Rust\nwill prioritize the fastest behavior it can, here are the rules for each memory type:"]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Global Allocation"}),":"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"const"})," is a fixed value; the compiler is allowed to copy it wherever useful."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"static"})," is a fixed reference; the compiler will guarantee it is unique."]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Stack Allocation"}),":"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Everything not using a smart pointer will be allocated on the stack."}),"\n",(0,s.jsx)(t.li,{children:"Structs, enums, iterators, arrays, and closures are all stack allocated."}),"\n",(0,s.jsxs)(t.li,{children:["Cell types (",(0,s.jsx)(t.code,{children:"RefCell"}),") behave like smart pointers, but are stack-allocated."]}),"\n",(0,s.jsxs)(t.li,{children:["Inlining (",(0,s.jsx)(t.code,{children:"#[inline]"}),") will not affect allocation behavior for better or worse."]}),"\n",(0,s.jsxs)(t.li,{children:["Types that are marked ",(0,s.jsx)(t.code,{children:"Copy"})," are guaranteed to have their contents stack-allocated."]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Heap Allocation"}),":"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["Smart pointers (",(0,s.jsx)(t.code,{children:"Box"}),", ",(0,s.jsx)(t.code,{children:"Rc"}),", ",(0,s.jsx)(t.code,{children:"Mutex"}),", etc.) allocate their contents in heap memory."]}),"\n",(0,s.jsxs)(t.li,{children:["Collections (",(0,s.jsx)(t.code,{children:"HashMap"}),", ",(0,s.jsx)(t.code,{children:"Vec"}),", ",(0,s.jsx)(t.code,{children:"String"}),", etc.) allocate their contents in heap memory."]}),"\n",(0,s.jsx)(t.li,{children:"Some smart pointers in the standard library have counterparts in other crates that don't need heap\nmemory. If possible, use those."}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"Container Sizes in Rust",src:n(89209).Z+"",width:"960",height:"540"})}),"\n",(0,s.jsxs)(t.p,{children:["-- ",(0,s.jsx)(t.a,{href:"https://docs.google.com/presentation/d/1q-c7UAyrUlM-eZyTo1pd8SZ0qwA_wYxmPZVOQkoDmH4/edit?usp=sharing",children:"Raph Levien"})]})]})}function u(e={}){let{wrapper:t}={...(0,r.a)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},89209:function(e,t,n){n.d(t,{Z:function(){return i}});let i=n.p+"assets/images/container-size-7fd54cbb2391e3e7310b0424c5f92cc1.svg"},50065:function(e,t,n){n.d(t,{Z:function(){return a},a:function(){return o}});var i=n(67294);let s={},r=i.createContext(s);function o(e){let t=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(r.Provider,{value:t},e.children)}},50610:function(e){e.exports=JSON.parse('{"permalink":"/2019/02/summary","source":"@site/blog/2019-02-09-summary/index.mdx","title":"Allocations in Rust: Summary","description":"While there\'s a lot of interesting detail captured in this series, it\'s often helpful to have a","date":"2019-02-09T12:00:00.000Z","tags":[],"readingTime":1.095,"hasTruncateMarker":true,"authors":[{"name":"Bradlee Speice","socials":{"github":"https://github.com/bspeice"},"key":"bspeice","page":null}],"frontMatter":{"slug":"2019/02/summary","title":"Allocations in Rust: Summary","date":"2019-02-09T12:00:00.000Z","authors":["bspeice"],"tags":[]},"unlisted":false,"lastUpdatedAt":1731204300000,"prevItem":{"title":"Making bread","permalink":"/2019/05/making-bread"},"nextItem":{"title":"Allocations in Rust: Compiler optimizations","permalink":"/2019/02/08/compiler-optimizations"}}')}}]);