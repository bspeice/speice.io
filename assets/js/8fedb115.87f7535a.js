"use strict";(self.webpackChunkspeice_io=self.webpackChunkspeice_io||[]).push([["4593"],{5959:function(e,t,n){n.r(t),n.d(t,{assets:function(){return l},contentTitle:function(){return r},default:function(){return p},frontMatter:function(){return a},metadata:function(){return o},toc:function(){return u}});var o=n(19395),i=n(85893),s=n(50065);let a={title:"Allocations in Rust: Compiler optimizations",description:"A lot. The answer is a lot.",date:new Date("2019-02-08T12:00:00.000Z"),last_updated:{date:new Date("2019-02-10T12:00:00.000Z")},tags:[]},r=void 0,l={authorsImageUrls:[]},u=[];function c(e){let t={p:"p",...(0,s.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.p,{children:"Up to this point, we've been discussing memory usage in the Rust language by focusing on simple\nrules that are mostly right for small chunks of code. We've spent time showing how those rules work\nthemselves out in practice, and become familiar with reading the assembly code needed to see each\nmemory type (global, stack, heap) in action."}),"\n",(0,i.jsx)(t.p,{children:"Throughout the series so far, we've put a handicap on the code. In the name of consistent and\nunderstandable results, we've asked the compiler to pretty please leave the training wheels on. Now\nis the time where we throw out all the rules and take off the kid gloves. As it turns out, both the\nRust compiler and the LLVM optimizers are incredibly sophisticated, and we'll step back and let them\ndo their job."})]})}function p(e={}){let{wrapper:t}={...(0,s.a)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},50065:function(e,t,n){n.d(t,{Z:function(){return r},a:function(){return a}});var o=n(67294);let i={},s=o.createContext(i);function a(e){let t=o.useContext(s);return o.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),o.createElement(s.Provider,{value:t},e.children)}},19395:function(e){e.exports=JSON.parse('{"permalink":"/2019/02/08/compiler-optimizations","source":"@site/blog/2019-02-08-compiler-optimizations/index.mdx","title":"Allocations in Rust: Compiler optimizations","description":"A lot. The answer is a lot.","date":"2019-02-08T12:00:00.000Z","tags":[],"readingTime":3.695,"hasTruncateMarker":true,"authors":[],"frontMatter":{"title":"Allocations in Rust: Compiler optimizations","description":"A lot. The answer is a lot.","date":"2019-02-08T12:00:00.000Z","last_updated":{"date":"2019-02-10T12:00:00.000Z"},"tags":[]},"unlisted":false,"lastUpdatedAt":1731204300000,"prevItem":{"title":"Allocations in Rust: Summary","permalink":"/2019/02/summary"},"nextItem":{"title":"Allocations in Rust: Dynamic memory","permalink":"/2019/02/a-heaping-helping"}}')}}]);